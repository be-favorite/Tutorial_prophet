---
title: "<center> **<font size = 5>R 유저들을 위한 단변량 시계열 예측 모형 Prophet 소개 **</font> </center>"
author: "<center> <font size = 3> 방태모 </font> </center>"
date: "<center>`r Sys.Date()`</center>"
output: 
  html_document:
      toc: yes
      toc_depth: 4
      toc_float: yes
      theme: sandstone
      highlight: tango
---
<center> If you are familiar with English, Here's the original text of the material:  </center>

<center>[Prophet Documentation](https://facebook.github.io/prophet/docs/quick_start.html#r-api) </center>

<center> The following text was written with reference to the above link.`r emo::ji("blush")` </center>

<style>
.math {
  font-size: small;
}
</style>

<br>

이 자료는 Facebook에서 제안하는 Prophet 모형을 소개하는 질 좋은 튜토리얼 자료를 찾고 있는 한국 R 유저들을 위해 만들었습니다. Facebook에서 훌륭한 [튜토리얼](https://facebook.github.io/prophet/docs/quick_start.html#r-api)을 제공하고 있으나, 영어로 된 자료라 영어에 능숙하지 않은 유저들은 약간 불편할 수 있겠다는 생각을 했어요. 안그래도 공부에 집중하기 힘든데, 영어로된 자료면 더 하기 싫을 때가 있죠. 물론, 해당 글도 Facebook에서 제공하는 튜토리얼을 기반으로 제 의견을 첨가하여 작성했습니다. 혹시 Prophet의 실제 적용뿐만 아니라, 자세한 이론적 부분이 궁금하다면 [제 블로그](https://be-favorite.tistory.com/64)를 참고해주시면 될 것 같습니다. 

Prophet 모형을 이렇게 소개하는 이유는 Prophet 논문 [Talyor and Letham (2018)](http://lethalletham.com/ForecastingAtScale.pdf)을 들여다 봤을 때, Facebook에서 해당 모형을 만든 motivation이 너무 매력적이었기 때문이에요. 시계열 예측 모형이 필요로 되는 실무자라면 이론적 부분은 차치하고 이 motivation만 이해해도 Prophet 모형을 얼른 적용해보고 싶을 겁니다.`r emo::ji("sunglasses")`

* `r emo::ji("exclamation")`도메인 지식은 갖추었으나, 시계열을 다루는 지식이 부족한 실무자들을 위해
  + 실제 통계학 전공자들도 시계열 분석을 처음 공부할 때 어려움을 느끼는 경우가 많고, 대표적 통계적 시계열 예측모형이라 할 수 있는 ARIMA 모형을 실무에 적용하기 위해서는 공부해야할 것들이 많음. 아울러, ARIMA 모형의 경우 결측이 존재해서도 안됨
* `r emo::ji("exclamation")`유연성(flexibility), 확장성(scalable)이 뛰어나며 Business time series에 유연하게 적용할 수 있는 모형의 필요성
  + ARIMA 모형은 각 자료가 갖는 특성들을 유연하고 세밀하게 반영하기 힘듬.
  
일단 첫 번째 motivation이 매우 감명깊었어요. Prophet 모형은 시계열을 3가지 요소로 분해하고 각 요소를 시간의 함수로 가법적으로 모형화하는데, 해당 자료에 대한 이해가 깊은 도메인 지식이 풍부한 실무자라면 이 튜토리얼만 잘 이해하고 수행해본다면 모형을 advance하는데 큰 어려움을 겪지 않을거라 생각합니다. 저도 이렇게 자료를 만들면서 "Prophet 모형을 도메인 지식이 풍부한 실무자가 자유자재로 다룰 줄 안다면, 어떤 단변량 시계열 모형을 가져와도 결코 뒤쳐지진 않겠구나."하고 생각했어요. 아무튼, 이 자료에 나와있는 다양한 예제들을 수행하다보면 저처럼 도메인 지식의 중요성을 느낄 수 있을 겁니다.`r emo::ji("smile")` 또 하나 마음에 들었던 점은, {tidyverse}와 [{tidymodels}](https://github.com/be-favorite/Tutorial_tidymodels) (see, the tutorial, if you want a gentle introdunction)에 익숙한 R 유저로써 세부적인 옵션들을 조정하고 모형을 적합하는 코드들이 파이프연산자(the pipe operator, %>%)와 {dplyr}의 동사들과 함께 동작하기 상당히 편하게 설계되어있던 점입니다.`r emo::ji("heart_eyes")`

좀 더 자세한 Prophet 모형의 이론적 부분이 궁금하시다면 제가 글의 초반부에 말씀드린 제 블로그를 참고해주세요. 혹시, 제 블로그 글만으로 부족하다거나 모호한 부분이 있다면 해당 블로그의 글에 댓글을 달아주시거나 위의 Prophet 논문 링크를 클릭하여 참고하시면 더 좋을겁니다! 해당 튜토리얼이 단변량 시계열 예측 모형이 필요로 되는 실무자들에게 조금이나마 도움이 됐으면 좋겠습니다.`r emo::ji("blush")`

이제 튜토리얼을 하러 가봅시다.`r emo::ji("runner")`

<br>

## **1 Quick Start** {.tabset .tabset-fade .tabset-pills}
***
첫 번째 챕터는 Quick Start로 Prophet 모형 적합의 디테일한 부분을 설명하지 않고, 러프하게 소개할 것이다. 

### 1.1 Preparing
R에서 Prophet 모형을 제공하는 패키지는 {prophet}이다. 먼저 해당 패키지를 불러온다. 패키지가 설치되어 있지 않은 경우 `install.packages("prophet")`를 통해 CRAN(The Comprehensive R Archive Network)에서 내려받을 수 있다. 그리고, 해당 예제에서 쓸 추가적인 패키지를 불러온다. {vroom}은 파일을 읽을 목적으로, {tidyverse}는 data wragling, {lubridate}는 날짜를 다루기 위해 불러왔다. {lubridate}가 {base}의 날짜 함수들보다 훨씬 직관적이므로, 배워둘만한 가치가 있다(see, `vignette("lubridate", package = "lubridate")`).

```{r}
library(tidyverse)
```

```{r, message = FALSE}
library(prophet)
library(lubridate)
library(vroom)
ggplot2::theme_set(theme_light())
loaded_package <- c("prophet", "vroom", "lubridate")
.version <- map(loaded_package, packageVersion)
names(.version) <- loaded_package
.version
```

[Facebook의 Github repository - prophet](https://github.com/facebook/prophet)에서는 {Wikipediatrend} 패키지에서 스크랩한 다양한 예제 자료를 각 챕터에 맞게 제공하는데, Quick Start에서는 [Peyton Manning(NFL의 쿼터백)의 위키피디아 페이지 일별 조회 수에 로그를 취한 자료](https://github.com/facebook/prophet/blob/master/examples/example_wp_log_peyton_manning.csv)를 사용할 것이다.
```{r, message = "FALSE"}
wp_log_peyton <- vroom("./data/example_wp_log_peyton_manning.csv", delim = ",")
glimpse(wp_log_peyton)
```

Prophet 모형을 적합하는 `prophet::prophet()`에서는 기본적으로 날짜를 나타내는 열 `ds`와 측정값(또는 관측값, observed values)을 나타내는 열 `y`을 갖는 데이터프레임을 요구하며, 물론 티블도 문제없다. 페이스북에서 제공하는 toy data답게 해당 자료의 각 열의 이름과 그 성분은 `prophet()`에서 요구하는 것에 만족하므로, 따로 다른 처리를 해줄 것이 없다.
```{r}
summary(wp_log_peyton)
```

해당 자료는 2007-12-10부터 2016-01-20까지 일별로 기록된 자료임을 알 수 있다.

### 1.2 Quick view on Prophet
바로 Prophet을 적합해보자:
```{r, message = FALSE}
mod <- prophet(wp_log_peyton)
```

`prophet()`에는 조정할 수 있는 함수의 인수(argument)가 매우 다양한데, 이는 다음 챕터에서 자세하게 설명하려고 한다. 이번 챕터는 Quick Start니까.`r emo::ji("blush")` Prophet 모형의 예측은 날짜를 나타내는 열 `ds`를 갖는 데이터프레임을 기반으로 만들어진다. 다음의 `make_future_dateframe()`은 모형 객체와 예측 기간의 수를 인수로 받아, 해당 예측 기간의 날짜를 `ds` 열로 하는 데이터프레임을 만들어준다. 향후 1년을 예측하기 위해 `periods` 인수에 365를 설정하였다:
```{r}
future <- make_future_dataframe(mod, periods = 365)
glimpse(future)
```

예측은 R의 예측 모델링에서 흔히 쓰이는 함수 `predict()`로 수행한다. 앞서 만든 데이터프레임과 모형객체를 인수로 받는다. 그런데 `predict()`와 같은 함수는 어떻게 다양하고 서로 다른 모형 객체를 인수로 받아 그에 알맞는 예측값을 제공해 줄까? 이 궁금증은 Python의 기초를 배우며 풀리게 되었다. 해당 글의 주제와는 조금 벗어나지만 알아두면 나쁘지 않다고 생각하기 때문에 간단히 설명하고 넘어가려고 한다. 

Python에는 클래스(class)와 메서드(method)라는 개념이 존재한다. 하나의 클래스 내부에는 여러가지 함수가 존재하는데 이 각각의 함수를 메서드라고 칭한다. 클래스는 객체(object)를 표현하기 위한 문법으로, 프로그래밍에서 객체를 만들 때 사용하는 것이 클래스이다. 예를 들어 게임을 만든다고 하면 기사, 마법사 등의 직업별로 클래스를 만들어 표현할 수 있다. 그리고, "기사"라는 클래스를 표현하려면 체력, 마나 등이 필요하고 칼로 베기, 찌르기 등의 스킬이 있어야 한다. 여기서 전자를 클래스의 속성(attribute)이라 부르고, 후자를 메서드라 부른다. 이러한 프로그래밍 방법을 객체지향(object-oriented) 프로그래밍이라 한다. 객체지향 프로그래밍은 복잡한 문제를 잘게 나누어 객체로 만들고, 객체를 조합하여 문제를 해결한다. 객체지향 프로그래밍의 장점은 복잡한 문제를 처리하는데 유용하며, 기능을 개선하고 발전시킬 때도 해당 클래스만 수정하면 되므로 유지 보수에도 효율적이라는 점이다. 

R의 기초부터 배운 사람이라면 한번 쯤은 R이 객체지향 언어라는 말을 들어봤을 것이다. 즉, Python과 R은 객체 지향언어에 해당한다. R은 Python과 달리 개발을 주 목적으로 만들어진 언어는 아니므로, 클래스와 메서드 개념을 따로 배우지 않아도 코딩할 때는 사실 딱히 어려움이 없다. 물론, 나도 클래스와 메서드에 대한 개념이 없이 R을 오랫동안 사용했었지만 크게 어려움을 느끼진 않았다.`r emo::ji("sweat")` 그러나, 이러한 개념을 알아두면 R에서 편한점이 하나 있다. R에서 클래스, 메서드 개념을 몰라도 문제가 없었던 이유는 Python과는 달리 메서드를 생략해도 인수로 받는 객체에 따라 자동으로 알맞는 메서드를 호출하기 때문이다. 예를 들어, `predict()` 함수는 알다시피 R에서 여러가지 모형(e.g. lm(), randomForest()) 객체의 예측값을 불러온다. 이는 사실 각각의 모형 객체에 따라 적절한 메서드가 호출 되기때문이다. 예를 들어, 다음 코드 블럭에서 우리는 Prophet 모형 객체로부터 예측값을 얻기 위해 `predict()`를 사용하였지만, 사실은 `predict.prophet()`이 자동으로 호출된 것이다. 만약, python이였다면 메서드를 명시하여 `predict.prophet()`을 호출해야 했을 것이다. 이러한 개념을 알고 있을 때의 편한 점은 R의 강력한 `help()`기능에 이용할 수 있다는 것이다. 예를 들어, `?predict.prophet`, `help(predict.prophet)`을 하면 구체적으로 해당 메서드에 대한 설명과 사용법을 볼 수 있다. 클래스와 메서드에 대한 개념이 없었던 R 유저들은 이렇게 다양한 객체에 맞는 메서드를 자동으로 불러와서 실행되는 함수에서 궁금한 점을 마주했을 때 `?predict` 나 `help(predict)`를 수행하면 generic 함수에 대한 사항만 나와서 조금 곤란했던 경우가 있을 것이다. 이제 이런 문제를 겪지 않을 수 있다.`r emo::ji("smile")`

이제 다시 본론으로 돌아가서, 적합한 prophet 모형의 예측값을 생성하기 위해 `predict()`를 수행한다:
```{r, cache = TRUE}
pred <- predict(mod, future)
glimpse(pred)
```

Prophet 모형 객체에 `predict()`를 수행하면 여러 열을 갖는 데이터프레임 객체를 반환해준다. lower(하한)와 upper(상한)는 Prophet에서 제공하는 uncertainty interval에 해당하는데, 이 부분에 대한 설명은 챕터 3.5에서 자세하게 설명할 것이다. 본 챕터에서는 날짜, 예측값, 예측값의 하한, 상한 값만을 불러와서 검토해보자:
```{r}
pred %>% 
  select(ds, starts_with("yhat")) %>% 
  head()
```
그리고, `predict()`를 통해 반환된 예측값들을 갖는 객체와 Prophet 모형 객체로 `plot()`을 수행하면, uncertainty interval을 포함하는 관측값과 적합값의 시도표를 그릴 수 있다:
```{r, fig.align = "center", out.width = "60%", cache = TRUE}
plot(mod, pred)
```

위 그래프는 다음의 함수를 이용하면 interative하게 그릴 수도 있다:
```{r, warning = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
dyplot.prophet(mod, pred)
```

서론에서 Prophet 모형은 시계열을 3가지 요소(추세, 계절, 휴일효과)로 분해하고 각 요소를 시간의 함수로 모형화 한다는 말을 했었다. `prophet_plot_components()`를 이용하면 다음과 같이 시계열이 추세, 주별 계절성분, 연별 계절성분으로 분해된 것을 확인할 수 있다. 휴일효과는 모형 적합과정에서 반영하지 않았으므로 생략되었다. 휴일효과의 반영은 챕터 3.3.1에서 자세히 설명할 것이다.
```{r, fig.align = "center", out.width = "60%", cache = TRUE}
prophet_plot_components(mod, pred)
```

<br>

## **2 Details**
***
이제 모형 적합에서 고려할 수 있는 세부적인 인수들에 대해 파헤쳐보자. 

### 2.1 Saturaing Forecasts
Prophet에서는 예측값의 상한값과 하한값을 설정할 수 있다. 이를 영어로 Saturating Forecasts라 표현한다. 참고로, saturate는 "포화 상태로 만들다"라는 뜻이 있고 이를 풀어서 설명하면 어떤 것(st/sb)을 어떤 것으로 채우는 것이 불가능 하도록 또는 채울 필요가 없도록 완전히 채우는 것을 말한다(to fill something/somebody completely with something so that it is impossible or useless to add any more). 이번 챕터에서는 Facebook의 Github에서 제공하는 [R의 위키피디아 페이지 일별 조회 수에 로그를 취한 자료](https://github.com/facebook/prophet/blob/master/examples/example_wp_log_R.csv)를 사용할 것이다.
```{r, message = FALSE}
wp_log_r <- vroom("./data/example_wp_log_R.csv", delim = ",")
```


#### 2.1.1 Forecasting Growth
Prophet은 디폴트 설정으로 예측에 선형 모형을 사용한다. 어떤 시계열의 성장(growth)에 대한 예측을 수행할 때, 보통 해당 시계열이 취할 수 있는 최댓값이 존재한다(e.g. 총 인구 수, 시장의 총 규모, etc.). 이를 "적재력(carrying capacity)"이라 칭하고, 예측값은 해당 지점에서 포화(saturate)되어야 한다. 그리고, Prophet에서는 예측에 선형 모형뿐만이 아닌 로지스틱 함수의 성장 추세(i.e. 비선형)를 갖는 모형을 사용할 수도 있으며, 해당 모형을 설정할 때는 적재력을 반드시 명시해야한다. 다음과 같이 자료에 `cap` 열을 추가하여 적재력을 명시할 수 있다(Prophet의 성장 모형화는 자연 생태계의 인구 성장 추세와 유사함). toy data로 진행되는 이번 튜토리얼에서는 특정값을 가정하여 사용할 것이나, 일반적으로는 시장 규모에 대한 전문적 지식이나 자료를 반영하여 설정된다.
```{r}
wp_log_r2 <- wp_log_r %>% 
  mutate(cap = 8.5)
```

주의할만한 점은 `cap`은 자료의 모든 행에에 명시되어야한다는 점이며, 꼭 상수값만을 취해야하는 것은 아니다. 만약 시장 규모가 성장한다면, `cap`도 증가하는 값을 갖도록 설정할 수 있다. 이제 `cap`을 설정한 자료를 바탕으로 비선형의 추세를 갖는 Prophet을 적합한다:
```{r}
mod_logistic <- prophet(wp_log_r2, growth = "logistic")
```

예측을 진행하는 다음의 과정은 전과 동일하나, `make_future_dateframe()`을 통해 생성되는 데이터프레임에도 cap을 명시해주어야 한다. 이번에는 향후 5년까지 예측을 수행할 것이다:
```{r, fig.align = "center", out.width = "60%", cache = TRUE}
future <- make_future_dataframe(mod_logistic, periods = 1826) %>% 
  mutate(cap = 8.5)
pred_logistic <- predict(mod_logistic, future)
plot(mod_logistic, pred_logistic)
```

#### 2.1.2 Saturating Minimum
로지스틱 성장 곡선의 추세를 갖는 Prophet 모형은 `floor`열을 명시하면 최솟값도 포화시켜 조정할 수 있다. 방식은 `cap`을 설정했던 것과 동일하다
```{r, fig.align = "center", out.width = "60%", cache = TRUE}
wp_log_r3 <- wp_log_r2 %>% 
  mutate(
    y = 10-y,
    cap = 6,
    floor = 1.5)
future2 <- future %>% 
  mutate(
    cap = 6,
    floor = 1.5)
mod_logistic <- prophet(wp_log_r3, growth = "logistic")
pred_logistic <- predict(mod_logistic, future2)
plot(mod_logistic, pred_logistic)
```

아울러, 최솟값으로 포화하는 로지스틱 성장 추세의 모형을 사용할 경우, 반드시 적재력을 나타내는 열 `cap`도 명시하여야 한다.

### 2.2 Trend Changepoints
Prophet은 시계열의 변화점(changepoints)을 자동으로 탐지하고 추세에 적절하게 반영한다. 이번 챕터에서는 이러한 변화점에 관한 것을 조정할 수 있는 몇 가지 인수들을 소개하고자 한다.

#### 2.2.1 Automatic changepoint detection in Prophet {#anchor}
Prophet은 수많은 잠재적 변화점(changepoints)을 명시함으로써 변화점을 탐지한다. 각 잠재적 변화점에서는 변화가 일어날  
비율(rate) $\delta_j$를 가지며, 여기서 $j = 1, \cdots,S$로 $S$는 고려할 변화점의 총 갯수를 의미한다. 그리고, 추세 적합에 관여하는 $\boldsymbol{\delta}$는 희소 사전분포(sparse prior)를 따른다고 가정하며, 이는 Lasso 회귀(see more details [here](https://be-favorite.tistory.com/46?category=908019))의 목적함수에 쓰이는 L1-regularization(if you don't know what it means, see [here](https://be-favorite.tistory.com/30?category=894492))과 동일하다. 즉, 이는 본질적으로 Prophet 모형은 변화점이 될 수 있는 수많은 지점을 명시한 뒤에 그 중 가능한한 적은 지점을 변화점으로 사용하게 될 것임을 의미한다.

Prophet에서는 보통 많은 수의 변화점을 명시하고(e.g. 수년간 수집된 자료에 대해 월별로 변화점 명시) 사전분포로 $\delta_j \sim {\rm{Laplace}}(0, \tau)$를 사용한다(see details, [Talyor and Letham (2018)](http://lethalletham.com/ForecastingAtScale.pdf) - 3.1 The Trend Model). 여기서 모수 $\tau$는 비율 $\delta_j$를 변화시킴으로써 모형의 유연성(flexibility)을 조절한다. 즉, 추세 적합의 조절모수는 $\tau$라 할 수 있다. 예를 들어, $\tau$를 0까지 감소시키면 일반적인(standard, not-piecewise) 로지스틱 또는 선형 성장 곡선을 갖는 추세를 이루게 된다(i.e. 변화점이 없는 것과 동일). 그리고, 앞서 추세 적합에 관여하는 사전분포를 Lasso 회귀의 목적함수에 쓰이는 L1-regularization과 동일하다고 했는데, 그 이유는 Lasso의 회귀계수 추정량을 베이지안 관점으로 풀어보면 회귀계수 추정량의 사전분포는 다음과 같기 때문이다($\sigma^2$은 $I$라 가정):  

<br>
${\boldsymbol{\beta}} \sim {\rm{DE}}(0, \lambda I)$
<br>

여기서 조절모수 $\lambda$는 $\tau$와 동일한 역할을 하고, ${\rm{DE}}$는 이중지수(double exponential) 분포로 다른 말로는 라플라스(Laplace) 분포라고 일컫는다. 이로써 둘은 완벽하게 동일하다는 것을 확인할 수 있다.

Quick Start 챕터에서 수행했던 Peyton Manning의 위키피디아 페이지 조회수 예측을 고려해보면, Prophet은 다음 그림에서 처럼 default로 25개의 잠재적 변화점을 시계열의 시작 날짜부터 80% 지점까지 균일하게 둔다:
```{r figure1, echo = FALSE, fig.cap = "출처: facebook.github.io", fig.align = "center", out.width = "60%"}
knitr::include_graphics("./fig/trendchangepoints_fig1.png")
```

여기서 점선으로 그어진 수직선이 곧 잠재적 변화점을 의미한다. 수많은 잠재적 변화점을 두긴 했지만, 변화가 일어날 가능성($\delta_j$)의 조절이 희소 사전분포로 이루어지기 때문에 대부분의 변화점들은 사용되지 않을 것이다. 이는 각 변화점에서 비율의 크기를 시각화하여 확인할 수 있다:
```{r figure2, echo = FALSE, fig.cap = "출처: facebook.github.io", fig.align = "center", out.width = "60%"}
knitr::include_graphics("./fig/trendchangepoints_fig2.png")
```
잠재적 변화점은 default로 25개가 고려되는데, 모형 적합을 수행하는 함수 `prophet()`의 `n_changepoints` 인수 통해 조정할 수 있다. 다만, `n_changepoints`은 자료에 따라 최적의 값이 다르므로 분석자의 직관에 의존하지 않은 regularization을 통한 튜닝이 필요로 될 것이다. 여기서 잠깐만 용어 정리를 하고 가자.

* regularization: training error가 아닌 generalization error를 줄이는 모든 행위를 통칭함. 즉, 해당 학습 알고리즘에 어떤 수정(modification)을 가하는 행위를 말함.
* generalization: 모형 적합에 쓰이지 않은 자료(unobserved data, i.e. test data)에도 좋은 성능을 보여주는 능력을 말함. 즉, 시험 자료(test data)에 대한 error는 generalization error에 해당.

이렇게 굳이 용어 정리를 하고가는 이유는, 위와 같이 [머신러닝에서 자주 등장하는 용어](https://be-favorite.tistory.com/30?category=894492)들을 간혹 머릿속에 정의가 확실하게 안된채로 혼동하여 쓰는 경우를 많이 봤기 때문이다. 용어 정의가 확실히 안되면 글을 쓰는 사람, 읽는 사람, 강의를 하는 사람, 듣는 사람 모두가 힘들어 진다.`r emo::ji("disappointed_relieved")` 특히, 통계학, 머신러닝 등의 도메인에서는 정확한 용어 정의가 중요하다.

다시 본론으로 돌아와서, 이러한 잠재적 변화점들의 시각화는 `add_changepoints_to_plot()`을 이용하면 된다. {prophet}의 그림들은 {ggplot2} 형태로 그려지기 때문에, 다음과 같이 `+` 연산자를 사용하여 레이어를 쌓을 수 있다.
```{r, fig.align = "center", out.width = "60%", cache = TRUE}
plot(mod, pred) + 
  add_changepoints_to_plot(mod)
```

잠재적 변화점이 default로 시계열의 시작 날짜부터 80% 지점까지 설정되는 이유는 추세를 확실하게 파악하기 위해 충분한 시계열의 길이를 확보하기 위함이며, 끝의 20% 부분에서 잠재점 변화점을 고려하지 않는 이유는 시계열의 끝부분에서 탐지되는 변화점들에 의해 과적합이 일어나는 것을 방지하기 위함이다. 이러한 `prophet()`의 default 값은 꽤 잘 작동하는데, 모든 상황에서 그렇진 않으며 `changepoint_range` 인수을 통해 조정이 가능하다. 예를 들어, `prophet(data, changepoint.range = 0.9)`는 시작 지점부터 90% 지점까지의 잠재적 변화점을 고려하라는 말이다.

#### 2.2.2 Adjusting trend flexibility {#anchor}
만약 추세 변화가 과적합 또는 과소적합 되었다면,  `change.prior.scale`로 희소 사전분포의 모수 $\tau$를 조정하여 추세 변화의 유연성(flexibility)을 조절할 수 있다. 즉, `change.prior.scale`의 크기($\tau$)를 키울수록 추세 변화는 flexible해지고, 과적합 가능성이 있을 것이다. 해당 인수의 default 값은 0.05로 설정되어 있다. 다음과 같이 0.5로 키우면 탐지된 추세가 더 flexible 해짐을 확인할 수 있다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
mod <- prophet(wp_log_peyton, changepoint.prior.scale = 0.5)
future <- make_future_dataframe(mod, periods = 365)
pred <- predict(mod, future)
plot(mod, pred)
```

반대로, 줄이면 다음과 같이 추세의 flexibility를 줄일 수 있다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
mod <- prophet(wp_log_peyton, changepoint.prior.scale = 0.001)
plot(mod, pred)
```

적절한 `changepoint.prior.scale`($\tau$)을 찾기 위해서는 튜닝이 필요하다. 이는 [2.8.2](#anchor)에서 다룰 것이다.

#### 2.2.3 Specifying the locations of the changepoints
마지막으로, 변화점의 위치를 자동으로 결정하는 것이 아닌 분석자가 그 위치를 명시할 수도 있다. `changepoint` 인수에 변화점이 놓이기를 원하는 날짜를 설정해주면 된다. 그럼 추세의 잠재적 변화점은 해당 지점에서만 고려될 것이다.
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
mod <- prophet(wp_log_peyton, changepoints = c("2014-01-01"))
plot(mod, pred) + 
  add_changepoints_to_plot(mod)
```

### 2.3 Seasonality, Holiday Effects, And Regressor
이번 챕터에서는 계절성, 휴일효과, 그리고 추가적인 회귀자(regressor)도 custom하는 것에 방법에 대해 소개한다. 챕터 하나하나를 배우면서 자료의 특성을 완성도있게 반영할 수 있는 당신만의 Prophet 모형을 설정할 수 있을 것이다.`r emo::ji("smile")`

#### 2.3.1 Modeling Holidays and Special Events  {#anchor}
먼저, 휴일 또는 특별한 이벤트가 있는 날을 모델링하는 방법에 대해 알아보자. 휴일효과는 다음과 같이 직관적으로 반영할 수 있다:
```{r}
playoffs <- tibble(
  holiday = "playoff",
  ds = ymd(c("2008-01-13", "2009-01-03", "2010-01-16",
             "2010-01-24", "2010-02-07", "2011-01-08",
             "2013-01-12", "2014-01-12", "2014-01-19",
             "2014-02-02", "2015-01-11", "2016-01-17",
             "2016-01-24", "2016-02-07")),
  lower_window = 0,
  upper_window = 1
)
superbowls <- tibble(
  holiday = "superbowl",
  ds = ymd(c("2010-02-07", "2014-02-02", "2016-02-07")),
  lower_window = 0,
  upper_window = 1
)

holidays <- bind_rows(playoffs, superbowls)
```


NFL이 쿼터백 Peyton Manning의 위키피디아 페이지 일별 조회 수에 관한 자료이므로, 미국의 가장 큰 스포츠 행사 NFL의 챔피언십 슈퍼볼(Super Bowl)의 플레이오프와 결승전을 휴일효과로 반영해보았다. 그리고, Prophet의 휴일효과 반영에서는 중요한 휴일 또는 특별한 이벤트가 있는 당일의 전후로 효과를 다르게 줄 수 있는데, 이를 반영 할 수 있는 열이 `lower_window`와 `upper_window`에 해당한다. 예를 들어, 위 코드처럼 `lower_window = 0`, `upper_window = 1`을 설정하면 해당 이벤트의 다음날 효과를 다르게 주라는 뜻을 말한다. 이렇게 특정 휴일의 당일 전후에 효과를 포함시는 것을 휴일의 창(a window of days)이라 칭한다. 특히, 우리나라의 추석이나 설과 같은 명절은 추석과 설 당일 전후로 휴일의 창을 반영해야할 것이다.
```{r, message = FALSE, cache = TRUE}
mod <- prophet(wp_log_peyton, holidays = holidays)
pred <- predict(mod, future)
pred %>% 
  select(ds, playoff, superbowl) %>% 
  filter(abs(playoff + superbowl) > 0) %>%
  tail(10)
```

휴일효과가 반영된 결과는 위 코드블럭에서처럼 예측을 수행한 객체에서 확인할 수 있으며, 시계열을 3요소로 분해한 그림에서도 확인할 수 있다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
prophet_plot_components(mod, pred)
```

휴일효과를 반영하는 요소의 그림을 보면 플레이오프가 진행되는 날에 값이 튀고(spike), 특히 슈퍼볼 결승전에 크게 값이 튀는 것을 확인할 수 있다. 개개의 휴일효과를 확인해볼 수도 있다. 예를 들어, 슈퍼볼 결승전에 대한 휴일효과만을 보고싶다면 `plot_forecast_component(mod, forecast, "superbowl")`를 수행하면 된다.

#### 2.3.2 Built-in Country Holidays
{prophet}에서는 미국의 국경일 목록을 기본적으로 제공한다. 자세한 내용은 [여기서](https://github.com/dr-prodigy/python-holidays) 확인할 수 있다. 해당 페이지에서 확인할 수 있듯이 Python에서는 holidays라는 패키지를 통해 다양한 나라의 국경일 목록을 제공하고 있으나, 아쉽게도 R에서는 지원이 안된다. Facebook 너무하다.`r emo::ji("anger")` 기본적으로 제공되는 국경일 목록은 `add_country_holidays()`를 통해 불러올 수 있고, 다음과 같은 과정으로 적합한다. 사전에 우리가 설정했던 `holidays`를 반영하고, 그 뒤에 {prophet}에서 제공하는 미국의 국경일을 반영한 뒤에 자료에 prophet 모형을 적합한다.
```{r, message = FALSE, cache = TRUE}
mod <- prophet(holidays = holidays) %>% 
  add_country_holidays(country_name = "US") %>% 
  fit.prophet(wp_log_peyton)
```

모형 적합에 사용된 휴일효과에 대한 정보는 다음과 같이 확인할 수 있다:
```{r}
mod$train.holiday.names
```

마지막으로 해당 모형 객체로 예측을 수행한 뒤에, 반영된 휴일효과를 시각화하여 확인해보자:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
pred <- predict(mod, future)
prophet_plot_components(mod, pred)
```

#### 2.3.3 Fourier Order for Seasonalities
Prophet에서는 푸리에 급수(Fourier series)로 계절성을 추정한다(see details, [Talyor and Letham (2018)](http://lethalletham.com/ForecastingAtScale.pdf) - 3.2 Seasonality):

<center> $s(t) = \sum_{n=1}^N (a_n cos(\frac{2 \pi nt}{P}) + b_n sin(\frac{2 \pi nt}{P}))$ </center>

푸리에 급수의 아이디어는 임의의 주기함수를 주기가 조금씩 다른 정현파(sin 함수, cos 함수)의 합으로 나타내는 것에 있으며, Prophet에서는 이 아이디어를 그대로 이용하여 계절성을 추정한다. 여기서 $N$을 푸리에 차수(Fourier order)라고 하며 크기를 키울수록 계절성은 flexible 하게 추정된다. 또한, sin 함수와 cos 함수에 대해 추정이 필요하므로 총 2N개의 모수 추정이 필요로 된다. 연별 계절성에 대한 푸리에 차수의 default 값은 10으로 Peyton Manning 자료의 연별 계절성은 다음과 같이 적합된다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
mod <- prophet(wp_log_peyton)
pred <- predict(mod, future)
prophet_plot_components(mod, pred)
```

마지막 그림을 확인하면 된다. Facebook에서 제공하는 예제에서는 `plot_yearly(mod)`를 수행하면 마지막 그림만을 보여주는데, `help(package = "prophet")`을 해보면 해당 함수는 제공되지 않고 있다. 그래서, 되는대로 위 함수를 이용하고 있다. `plot_forecast_component(mod, pred, "yearly")`도 이용할 수 있는데, 계절성의 변화를 1년에 걸쳐서 보여주는 위 그림과 달리 자료가 갖는 전 시점에서 계절성의 반복을 보여주다보니 연별로 반복되는 계절성을 정확하게 파악하기 위해선 위 그림이 더 낫다고 판단하여 `prophet_plot_components()`를 이용하였다. 푸리에 차수의 크기를 키울 경우 계절성은 좀 더 복잡한 형태(more flexible)로 추정될 것이다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
mod <- prophet(wp_log_peyton, yearly.seasonality = 20)
pred <- predict(mod, future)
prophet_plot_components(mod, pred)
```

푸리에 차수 $N$을 지나치게 크게 설정하면, 과적합을 야기할 수 있으니 적당한 N 값을 설정하는 것이 좋다. 자료마다 편차가 존재하겠지만, yearly 또는 weekly seasonality를 가지는 경우 각각 $N=10$, $N=3$으로 설정하면, 대부분의 문제에서 잘 작동한다. 아울러, 적절한 푸리에 차수 $N$의 결정은 교차검증을 통해 AIC와 같은 측도를 기준으로 결정할 수도 있다.

#### 2.3.4 Specifying Custom Seasonalities
시계열의 계절 주기가 둘 이상인 경우, Prophet은 default로 주별 계절성과 연별 계절성을 적합한다. 또한, sub-daily 자료(i.e. YYYY-MM-DD HH:MM:SS)일 경우 default로 일별 계절성을 적합할 것이다. 여기서 더 나아가, Prophet에서는 `add_seasonality()`로 다른 계절성들(i.e. monthly, quarterly, hourly)을 모형에 반영할 수 있다. 해당 함수에서는 원하는 계절성 주기, 한 주기의 지속 시기(float number of days in one period), 푸리에 차수를 지정할 수 있다. 아울러 추가적인 인수로 계절성에 과적합 또는 과소적합의 문제가 보일때, 계절성에 대한 사전분포의 크기($\tau$)를 조정할 수 있는데 이는 [2.3.6](#anchor)에서 다루려고 한다. 다음의 예는 Peyton Manning 자료에 default로 적합되는 주별 계절성 대신 월별 계절성을 적합한 것이다:

```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
mod <- prophet(weekly.seasonality = FALSE) %>% 
  add_seasonality(name = "monthly", period = 30.5, fourier.order = 5) %>% 
  fit.prophet(wp_log_peyton)
pred <- predict(mod, future)
prophet_plot_components(mod, pred)
```

#### 2.3.5 Seasonalities that depend on other factors
시계열 자료의 계절성은 다른 요인에 의존할 수도 있다. 예를 들어, 여름에는 주별 계절성의 패턴이 다르다거나, 주중 그리고 주말의 일별 계절적 패턴이 다른 경우가 있을 수도 있다. Prophet에서는 이러한 유형의 계절성도 조건부 계절성을 사용하여 모델링할 수 있다. 

Peyton Manning 자료에 대해 이를 적용해보자. 주별 계절성은 default로 그 패턴이 1년 내내 동일하다고 가정한다. 그러나, Peyton Manning 자료의 주별 계절성의 패턴은 NFL의 시즌이 진행 중(on-season)일 때(일요일마다 경기가 있을 때)와 시즌이 종료된 시기(off-season)일 때 다를 것이라 기대할 수 있다. 이러한 주별 계절성은 on-season, off-season으로 주별 계절성을 분리하는 조건부 계절성을 사용하여 반영할 수 있다.

먼저 자료와 예측의 수행에 필요한 날짜 열을 갖는 데이터프레임에 각 날짜의 on-season, off-season 여부를 나타내는 logical vector 열을 각각 추가해준뒤, 조건부 계절성을 반영한 모형을 적합하고 예측을 수행한다. NFL 시즌은 9월부터 1월까지 진행된다:

```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
is.nfl_season <- function(ds){
  month(ds) >= 9 | month(ds) <= 1
}
wp_log_peyton_season <- wp_log_peyton %>% 
  mutate(
    on_season = is.nfl_season(ds),
    off_season = !is.nfl_season(ds)
    )
future_season <- future %>% 
    mutate(
    on_season = is.nfl_season(ds),
    off_season = !is.nfl_season(ds)
    )

mod_season <- prophet(weekly.seasonality = FALSE) %>% 
  add_seasonality(name = "weekly_on_season", period = 7, fourier.order = 3, condition.name = "on_season") %>% 
  add_seasonality(name = "weekly_off_season", period = 7, fourier.order = 3, condition.name = "off_season") %>%
  fit.prophet(wp_log_peyton_season)

pred_season <- predict(mod_season, future_season)
prophet_plot_components(mod_season, pred_season)
```

우리가 custom한 두 계절성을 위 그림에서 비교할 수 있다. 일요일마다 경기가 치뤄지는 NFL의 on-season을 나타내는 계절성의 경우 일요일과 월요일에 큰 증가가 있으나, off-season인 경우 일요일과 월요일에 딱히 증가가 없다(see the $y$-axis).

#### 2.3.6 Prior scale for holidays and seasonality {#anchor}
휴일효과와 계절성도 추세 적합에서처럼 과적합이 일어난 경우에 사전분포의 모수 조정을 통한 평활로 곡선의 형태를 덜 복잡하게(less flexible) 만들 수 있다. 

예를 들어, 푸리에 차수 $N = 10$인 연별 계절성분을 $X(t)$라 하면: 

<br>
<center> $X(t) = [cos(\frac{2 \pi (1)t}{365.25}), \cdots, sin(\frac{2 \pi (10)t}{365.25})]$ </center>
<br>
Prophet의 계절 요소는 다음과 같이 추정된다:

<br>
<center> $s(t) = X(t) {\boldsymbol{\beta}}$ </center>
<br>

단, 여기서 ${\boldsymbol{\beta}} \sim {\rm{Normal}}(0, \sigma^2)$으로 계절성에 대한 평활 사전분포를 가정한다. 즉, $\sigma^2$을 조절모수(tuning parameter)라고 할 수 있다.(see details, [Talyor and Letham (2018)](http://lethalletham.com/ForecastingAtScale.pdf) - 3.2 Seasonality)

휴일효과도 계절성과 유사한 방식으로 추정된다. 반영하고자 하는 각 휴일효과를 $i$라 하고, 각 휴일효과의 과거 및 미래 날짜들의 집합을 $D_i$라 하자. 그럼 시계열의 임의의 시점 $t$가 휴일 $i$에 포함되는지를 나타내는 지시함수를 정의할 수 있다. 예를 들어, 고려하고자 하는 휴일효과가 $1, 2, \cdots, L$개 존재한다고 하면, 앞서 계절성분을 정의했던 것과 유사하게 휴일효과에 대한 요소를 다음과 같이 정의할 수 있다:

<br>
<center> $Z(t) = [{\boldsymbol{1}}(t \in D_1), \cdots, {\boldsymbol{1}}(t \in D_L)]$. </center>
<br>

그럼, Prophet의 휴일효과는 최종적으로 다음과 같이 추정된다:

<br>
<center> $h(t) = Z(t) {\boldsymbol{\kappa}}$. </center>
<br>

여기서 ${\boldsymbol{\kappa}} \sim {\rm{Normal}}(0, \nu^2)$으로 계절성과 마찬가지로 평활 사전분포를 가정한다. 즉, 휴일효과의 조절모수는 $\nu^2$이라 할 수 있다. 아울러, 휴일효과의 경우 [2.3.1](#anchor)에서 휴일의 창이라는 효과를 통해 추석 또는 설 당일과 같은 명절의 주변 일자를 지정하여 효과를 다르게 줄 수 있다고 언급했었는데, 이렇게 휴일의 창으로 고려되는 날짜들 또한 각 날짜를 본질적으로 휴일 그 자체로 다루어 추정을 수행하기 때문에 가능해지는 것이다(see details, [Talyor and Letham (2018)](http://lethalletham.com/ForecastingAtScale.pdf) - 3.3 Holidays and Events).

계절성과 휴일효과의 적합을 조절하는 각 모수 $\sigma^2$과 $\nu^2$도 추세 적합을 조정하는 모수 $\tau$와 같이 그 크기를 키울수록 복잡한 효과를 추정하게 되고, 그에 따라 과적합의 우려가 커질 것이다. 그리고, 둘에 관해 마지막으로 언급하고 싶은 점은 [2.2.1](#anchor)에서 추세 적합에 관여하는 사전분포는 곧 Lasso 회귀의 L1-regularization과 동일하다고 했었는데, 계절성과 휴일효과에 관여하는 두 사전분포는 Ridge 회귀((see more details [here](https://be-favorite.tistory.com/29?category=908019)))의 L2-regularization과 동일하다. 마찬가지로 Ridge의 회귀계수 추정량을 베이지안 관점으로 풀어서 회귀계수 추정량의 사전분포를 구해보면 알 수 있다($\sigma^2$은 $I$라 가정):

<br>
${\boldsymbol{\beta}} \sim {\rm{Normal}}(0, \tau^2 I)$
<br>

단, 여기서 $\tau^2$은 $\frac{\sigma^2}{\lambda} = \frac{I}{\lambda}$에 해당한다($\sigma^2$은 계절성의 사전분포를 조절하는 모수가 아닌 분산을 의미한다). 이로써, 계절성과 휴일효과 각각의 사전분포를 조절하는 $\sigma^2$, $\nu^2$은 Ridge 회귀 추정량의 사전분포를 조절하는 $\tau^2$와 정확하게 동일함을 확인했다.

먼저 휴일효과는 `holidays.prior.scale`으로 $\nu^2$의 조정을 수행할 수 있다. default는 10으로 설정되어 있다.
```{r, message = FALSE, cache = TRUE}
mod <- prophet(wp_log_peyton, holidays = holidays, holidays.prior.scale = 0.05)
pred <- predict(mod, future)
pred %>% 
  select(ds, playoff, superbowl) %>% 
  filter(abs(playoff+superbowl) > 0) %>% 
  tail(10)
```

[2.3.1](#anchor)의 3번째 코드블럭의 결과와 비교해보면, 특히 superbowl 휴일효과의 크기가 약해졌음을 확인할 수 있다. 계절성의 경우 `seasonality.prior.scale`로 $\sigma^2$을 조정할 수 있다. 아울러, 사전분포의 크기는 더 세밀하게 조정이 가능하다. 예를 들어, 휴일효과의 경우 휴일효과에 대한 정보를 갖는 데이터프레임에 `prior.scale` 열을 만들어서 각 휴일효과에 대한 사전분포 크기의 조정이 가능하다. 계절성의 경우 `add_seasonality`를 통해 각 계절성의 사전분포의 모수 $\sigma^2$을 조정할 수 있다. 예를 들어, 주별 계절성을 반영하는 사전분포의 $\sigma^2$은 다음과 같이 설정할 수 있다:
```{r, message = FALSE, cache = TRUE}
mod <- prophet() %>% 
  add_seasonality(name = "weekly", period = 7, fourier.order = 3, prior.scale = 0.1)
```

#### 2.3.7 Additional regressors
Prophet에서는 `add_regressor`를 사용하여 추가적인 회귀자(regressor)를 모형에 반영할 수 있다. 회귀자는 모형 적합에 쓰이는 데이터프레임과 예측에 필요한 데이터프레임 모두에서 명시되어야 한다. 예를 들어, 우리는 다음과 같이 NFL 시즌 동안 일요일에 추가적인 효과를 추가할 수 있다. 반영된 효과는 마찬가지로 `prophet_plot_components()`에서 확인할 수 있다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
nfl_sunday <- function(ds) {
  month <- month(ds)
  as.numeric(
    (wday(ds, label = TRUE, abbr = FALSE) == "일요일") & (month >= 9 | month <= 1)
  )
}
wp_log_peyton_sun <- wp_log_peyton %>% 
  mutate(
    nfl_sunday = nfl_sunday(ds)
  )
mod_sun <- prophet() %>% 
  add_regressor("nfl_sunday") %>% 
  fit.prophet(wp_log_peyton_sun)
future_sun <- future %>% 
  mutate(
    nfl_sunday = nfl_sunday(ds)
  )
pred_sun <- predict(mod_sun, future_sun)
prophet_plot_components(mod_sun, pred_sun)
```

물론, NFL 시즌 중의 일요일은 모형 적합 과정에서 과거와 미래의 NFL 시즌 중의 일요일의 날짜 목록을 만들어 `holidays` 인수에 반영함으로써, 휴일효과로도 모형화가 가능하다. 그러나, `add_regressor`의 경우 `holidays`에 비해 추가적인 회귀자를 고려할 수 있는, 보다 일반적인 인터페이스를 제공한다. 특히, 회귀자는 이진형 지표만을 요구하는 것이 아니며, 또 다른 시계열을 회귀자로 사용할 수도 있다. 다만, 회귀자로 사용할 시계열의 경우 모형 적합에 쓰이는 과거값뿐만 아니라, 예측 날짜에 해당 하는 미래값도 알려져있어야 한다. 

회귀자로 쓰고싶은 시계열 자료에 과거값만 주어질 경우 한 가지 방법이 있다. 예를 들어, $y(t)$를 Prophet으로 모형화 하는데 시계열 $r(t)$를 회귀자로 포함시킬 경우, Prophet으로 먼저 $r(t)$의 미래값을 예측하고 해당 값들을 $y(t)$의 회귀자로 사용하는 것이다. 그러나, 이러한 방식은 $r(t)$가 $y(t)$보다 예측하기 쉬운 경우에만 유용할 수 있다. 그 예로 하위 수준의 예측에서 보다 최상위 수준(top-level)의 예측에서 더 높은 SNR(signal to noise ratio)을 갖는 계층적 시계열을 들 수 있다. SNR이 더 높다는 말은 곧 잡음(noise)가 더 작다는 말이며, 이는 즉 최상위 수준의 예측이 더 쉽다는 것을 뜻한다. 이러한 경우에, 최상위 수준의 예측값은 하위 수준의 각 시계열 예측의 회귀자로 쓰일 수 있다.

이번 예제에서 회귀자는 default로 가법(additive) 요소로 고려되었으며, 승법(multiplicative) 요소로도 고려될 수 있다. 다음 섹션이 승법성(mutiplicativity)에 대한 내용에 해당한다.

### 2.4 Multiplicative Seasonality
Prophet 모형은 기본적으로 계절성을 가법적 요소로 적합하며, 이는 곧 추세 요소에 계절성의 효과를 더하여 예측을 수행함을 의미한다. 그러나, 증가 추세를 갖는 시계열에서 계절성의 크기도 증가하는 경우엔 계절성을 승법적으로 고려해야 한다. 
[Facebook의 Github repository - prophet]에서 제공하는 다음의 [여객기 승객 수에 관한 일별 자료](https://github.com/facebook/prophet/blob/master/examples/example_air_passengers.csv)가 가법적 계절성이 작동하지 않는 예에 해당한다:

```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
air <- read_csv("./data/example_air_passengers.csv")
mod <- prophet(air)
future <- make_future_dataframe(mod, 50, freq = "m")
pred <- predict(mod, future)
plot(mod, pred)
```

해당 시계열은 명확하게 연도별(yearly) 계절성을 갖는 것으로 보이지만, 시계열의 시작점에서는 적합된 계절성이 너무 크고 끝 부분에서는 적합된 계절성이 너무 작다. 그 이유는, 해당 자료의 계절성은 Prophet 적합 과정에서 가정한 것처럼 가법 요소가 아닌, 추세에 따라 증가하는 승법적 계절 요소에 해당하기 때문이다.

승법적 계절성은 `seasonality.mode = "multiplicative"`로 설정할 수 있다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
mod <- prophet(air, seasonality.mode = "multiplicative")
pred <- predict(mod, future)
plot(mod, pred)
```

계절성이 추세의 증가에 알맞게 반영되어, 계절성이 잘 잡힌 모습을 확인할 수 있다. 시계열의 추정된 각 요소를 나타내는 그림을 그려보면 추세의 퍼센트(%)로 계절성이 나타난다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
prophet_plot_components(mod, pred)
```

휴일효과도 계절성처럼 승법적으로 모형화가 가능하다. 그리고, `seasonality_mode`에서 설정한 것에 따라 추가적인 계절성이나 회귀자도 해당 설정을 따르나, 계절성이나 회귀자를 추가할 때 `mode = "additive"` 또는 `mode = "multiplicative"`를 명시함으로써 기본 설정은 무시되도록 분석자가 원하는 요소로 반영할 수 있다.
```{r, cache = TRUE}
mod <- prophet(seasonality.mode = "multiplicative") %>% 
  add_seasonality("quarterly", period = 91.25, fourier.order = 8, mode = "additive") %>% 
  add_regressor("regressor", mode = "additive")
```

가법적 회귀자와 승법적 회귀자는 시계열의 각 요소를 나타내는 그림에서 분리된 패널에 그려진다. 그러나, 가법적 계절성과 승법적 계절성이 혼합되어 나타날 가능성은 거의없으므로, 일반적으로 이러한 계절성이 있을거라 예상하는 이유가 존재하는 경우에만 사용된다.

### 2.5 Uncertainty Intervals
Prophet은 기본적으로 예측값 $yhat$에 대한 uncertainty intervals을 제공한다. 예측의 uncertainty에는 3가지 요소(추세, 계절성, 추가적인 관측 잡음)가 있으며, uncertainty intervals에는 몇몇 중요한 가정이 있다는 점을 알아둬야 한다.

#### 2.5.1 Uncertainty in the trend
먼저 추세 요소에 대한 예측의 uncertainty에 관해 알아보자. 예측의 uncertainty에 대한 가장 큰 요소는 미래의 추세 변화에 대한 가능성을 반영하는 추세 요소라 할 수 있다. 이번 튜토리얼에서 지금까지 다룬 시계열들은 과거에 명확한 추세 변화를 보여주었으며, Prophet은 이를 탐지하고 적합한다. 그러나, 과거에 발생했던 추세 변화의 패턴이 쭉 이어진다고 과연 기대할 수 있을까? 이를 확실히 아는 것은 당연히 불가능하고, Prophet에서는 이를 미래는 과거와 비슷한 추세를 띨 것이라는 가정하에 최대한 합리적으로 처리한다. 좀 더 구체적으로 말하면, Prophet에서는 미래의 추세 변화의 평균적 크기와 주기가 과거에서 우리가 관측했던 바와 같을 것이라 가정한다. 이를 통해 미래의 추세 변화를 예측하고, 그들의 분포를 계산하여 uncertainty intervals을 얻는다. 그래서, 이러한 가정때문에 사실 추정된 uncertainty intervals이 정확한 범위를 가질거라 기대하긴 어렵다.

그러나, uncertainty intervals은 과적합의 유용한 척도가 된다. uncertainty 측정 방법의 한 가지 특성(property)은 `changepoint.prior.scale`($\tau$)를 키워 유연성(flexibility)를 높일 경우 예측의 uncertainty가 증가한다는 점인데, 이는 직관적으로도 당연하다. 추세 변화의 유연성을 키우면 더 많은 변화점이 탐지될 가능성이 커지고, 좀 더 복잡한 곡선을 적합하게 될 것이므로 미래 시점에 복잡한 추세 변화를 가정할 수록 당연히 uncertainty는 커질 것이기 때문이다. 

Prophet에서 uncertainty intervals의 기본적인 범위는 80%이며, `interval_width`를 통해 조정할 수 있다:
```{r, message = FALSE, echo = TRUE, eval = FALSE, cache = TRUE}
prophet(air, interval.width = 0.95) %>% 
  predict(future)
```

#### 2.5.2 Uncertainty in seasonality
Prophet은 기본적으로 추세와 관측 잡음에 대한 uncertainty만 제공하는데, 계절성에 대한 uncertainty를 얻기 위해서는 `mcmc.samples` 인수를 설정하여 베이지안 표집(Bayesian sampling)을 수행해야 한다. `mcmc.samples`는 기본적으로 0으로 설정되어 있으며, 이름에서 알 수 있듯이 베이지안 표집 방법 중 하나인 MCMC(Markov Chain Monte Carlo, 마코프 체인 몬테카를로)를 통해 계절성의 경험적 사후 분포(empirical posterior distribution)를 추정한다. 다음은 이를 Peyton Manning 자료의 6개월 예측에 수행한 것이다. 샘플 수가 커질 수록 추정은 오래 걸릴 것이다:
```{r, message = FALSE, warning = FALSE, cache = TRUE}
mod <- prophet(wp_log_peyton, mcmc.samples = 300)
future <- make_future_dataframe(mod, periods = 30.5*6)
pred <- predict(mod, future)
prophet_plot_components(mod, pred)
```

사후 예측 표본에 대한 값은 `predictive_samples(mod, future)`로 확인할 수 있다.

### 2.6 Outliers
이상점(outliers)은 2가지 방식으로 Prophet 모형의 예측값에 영향을 미칠 수 있다. 이번 챕터에서는 [잘못 기록된 이상점이 포함된 R의 위키피디아 페이지 일별 조회 수에 로그를 취한 자료](https://github.com/facebook/prophet/blob/master/examples/example_wp_log_R_outliers1.csv)를 사용할 것이다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
wp_outlier <- vroom("./data/example_wp_log_R_outliers1.csv", delim = ",")
mod_outlier <- prophet(wp_outlier)
future_outlier <- make_future_dataframe(mod_outlier, periods = 1096)
pred_outlier <- predict(mod_outlier, future_outlier)
plot(mod_outlier, pred_outlier)
```

적합된 추세는 꽤 합리적이여 보이긴 하지만, 예측값의 uncertainty intervals이 지나치게 넓게 추정되고 있다. 사실 Prophet에서 이상점을 처리하는 가장 좋은 방법은 이상점들을 제거하는 것이다. Prophet은 결측이 있는 자료에도 문제 없이 작동하기 때문이다. 과거값에 존재하는 이상점들을 `NA`로 처리하면, `make_future_dataframe()`을 통해 생성되는 예측에 필요한 객체에는 해당 날짜가 남아있을 것이며 Prophet은 해당 값에 대한 예측까지 제공해 줄 것이다.
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
wp_outlier_rmv <- wp_outlier %>%
  filter(ds <= ymd("2010-01-01") | ds >= ymd("2011-01-01") )
mod_outlier_rmv <- prophet(wp_outlier_rmv)
pred_outlier_rmv <- predict(mod_outlier_rmv, future_outlier)
plot(mod_outlier_rmv, pred_outlier_rmv)
```

앞서 다뤄본 이상점이 포함된 예제에서는 이상점들이 uncertainty intervals의 추정에는 큰 문제를 일으켰지만, 미래 예측값 `yhat`의 추정은 무리없이 수행하였다. 이상점이 포함된 자료가 항상 이렇게 uncertainty intervals의 추정에만 문제를 일으키는 것은 아니다. 2015년 6월에 여러 극단적인 이상점을 포함하고있는 다음 자료는 계절성 추정에 문제를 끼치며, 그에 따라 미래 예측값 `yhat`의 추정에 문제를 일으킨다.
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
wp_outlier2 <- vroom("./data/example_wp_log_R_outliers2.csv", delim = ",")
mod_outlier2 <- prophet(wp_outlier2)
future_outlier2 <- make_future_dataframe(mod_outlier, periods = 1096)
pred_outlier2 <- predict(mod_outlier2, future_outlier2)
plot(mod_outlier2, pred_outlier2)
```

앞전의 해결책과 동일하게, 2015년 6월 자료를 제거하고 다시 모형을 적합하자:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
wp_outlier2_rmv <- wp_outlier2 %>% 
  filter(ds < ymd("2015-06-01") | ds > ymd("2015-06-30"))
mod_outlier2_rmv <- prophet(wp_outlier2_rmv)
pred_outlier2_rmv <- predict(mod_outlier2_rmv, future_outlier2)
plot(mod_outlier2_rmv, pred_outlier2_rmv)
```

### 2.7 Non-Daily Data

#### 2.7.1 Sub-daily data
Prophet 모형은 YYYY-MM-DD HH:MM:SS 형태로 기록된 sub-daily 시계열 자료에도 적합할 수 있다(see the example csv [here](https://github.com/facebook/prophet/blob/master/examples/example_yosemite_temps.csv)). sub-daily 자료를 적합하는 경우 Prophet은 자동으로 일별 계절성을 적합한다. 이번 예제에서 쓰일 자료는 5분 간격으로 측정된 미국 요세미티 국립공원의 기온 자료에 해당한다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
yose <- vroom("./data/example_yosemite_temps.csv")
mod <- prophet(yose, changepoint.prior.scale = 0.01)
future <- make_future_dataframe(mod, periods = 300, freq = 60*60)
pred <- predict(mod, future)
plot(mod, pred) + 
  scale_x_datetime(date_labels = "%Y-%m-%d", date_breaks = "2 weeks")
```

적합된 일별 계절성도 `prophet_plot_components()`에서 확인할 수 있다.
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
prophet_plot_components(mod, pred)
```

#### 2.7.2 Data with regular gaps
Prophet은 일정한 gaps을 갖는 자료이기만 하면 적합이 가능하다. 예를 들어, 앞서 사용했던 예제의 관측치가 하루에 5분 간격으로 AM 00:00~AM 06:00까지만 수집되는 자료라 가정하고 분석을 진행해보자.
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
yose2 <- yose %>% 
  mutate(hour = hour(ds)) %>% 
  filter(hour < 6) %>% 
  select(-hour)
mod <- prophet(yose2)
future <- make_future_dataframe(mod, periods = 300, freq = 60*60)
pred <- predict(mod, future)
plot(mod, pred) + 
  scale_x_datetime(date_labels = "%Y-%m-%d", date_breaks = "2 weeks")
```

예측값을 보면 변동이 매우 크게 추정된 것을 확인할 수 있다. 그 이유는, 이전 예제와 달리 하루에 5분 간격으로 종일 측정된 자료가 아닌, 하루에 5분 간격으로 AM 00:00~AM 06:00까지만 수집되는 자료에 대해 일별 주기를 갖는 모형을 적합하여 일별 계절성의 추정이 잘 이루어지지 않기 때문이다. 이는 과거값들의 time window와 동일한 시점에 대해서만 예측값의 추정을 수행함으로써 해결할 수 있다. 즉, 미래 예측에도 하루에 5분 간격으로 AM 00:00~AM 06:00 시점에 대해서만 예측을 수행하는 것이다.
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
future2 <- future %>% 
  mutate(hour = hour(ds)) %>% 
  filter(hour < 6) %>% 
  select(-hour)
pred <- predict(mod, future2)
plot(mod, pred) + 
  scale_x_datetime(date_labels = "%Y-%m-%d", date_breaks = "2 weeks")
```

다른 일정한 gaps을 갖는 시계열 자료에도 똑같은 방법이 적용된다. 에를 들어, 일별로 측정된 과거값이 주중(weekdays)에만 기록된다면 주말에 대한 주별 계절성의 추정에 어려움을 겪을 것이기 때문에, 예측도 주중에 대해서만 수행해야 할 것이다.

#### 2.7.3 Monthly data
Prophet은 월별 자료에 대해서도 적합이 가능하다. 다만, Prophet은 기본적으로 연속 시간에 대한 모형이기 때문에 월별 자료를 적합한 다음 일별로 예측을 수행하면 당연히 좋지 않은 결과를 얻을 것이다. 이는 앞선 챕터 2.7.2의 내용과도 일맥상통한다. 이번 챕터에서는 [월별 미국 소매 판매량 자료](https://github.com/facebook/prophet/blob/master/examples/example_retail_sales.csv)로 10년 예측을 수행한다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
retail <- vroom("./data/example_retail_sales.csv")
mod <- prophet(retail, seasonality.mode = "multiplicative")
future <- make_future_dataframe(mod, periods = 3652)
pred <- predict(mod, future)
plot(mod, pred)
```

월별 자료로 향후 10년을 예측하는데 향후 10년 예측을 일별로 수행하였으므로 당연히 예측에 문제가 발생한다. 연별 계절성을 적합하는데 월별 자료는 매달 첫째날에 대한 관측값만 주어지기 때문에, 남은 날들에 대한 계절 요소는 식별할 수 없다. 이러한 계절성의 불확실성은 MCMC를 사용해 계절성의 uncertainty를 추정해보면 그림으로도 확인할 수 있다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
mod <- prophet(retail, seasonality.mode = "multiplicative", mcmc.samples = 300)
pred <- predict(mod, future)
prophet_plot_components(mod, pred)
```

매달 첫째날에는 uncertainty가 낮으나, 첫째날은 제외하면 사후 분산이 매우 크게 추정되여 uncertainty intervals이 매우 넓게 추정된 것을 확인할 수 있다. 이러한 경우 2.7.2에서 배운 해결책과 똑같은 원칙을 적용하면된다. 다음과 같이 `make_future_datarame()`에서 `freq` 인수로 주기를 설정할 수 있다.
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
future <- make_future_dataframe(mod, periods = 120, freq = "month")
pred <- predict(mod, future)
plot(mod, pred)
```

월별 자료에서는 연도별 계절성의 모형화를 이진형 회귀자로도 수행할 수 있다. `is_jan`, `is_feb`와 같은 각 월을 나타내는 이진형 회귀자 12개를 도입하는 것이다. 예를 들어, `is_jan`는 1월에 해당하는 날짜에만 1 값을 가질 것이다. 이 접근 방법도 앞선 예제에서 MCMC를 통해 확인했던 문제를 피할 수 있게 해줄 것이다. 그리고, 이렇게 회귀자를 추가하여 연별 계절성을 모델링 하는 경우 모형 적합을 수행할 때 꼭 `yearly_seasonality = FALSE`를 명시해주어야 한다.

#### 2.7.4 Holidays with aggregated data
휴일효과는 특정 날짜가 명시된 휴일에만 적용된다. 그래서, 주별 또는 월별 주기를 갖는 합산 자료에서는 특정 날짜가 명시된 휴일효과는 무시될 것이다. 예를 들어, 매주 일요일마다 수집된 주별 시계열에서 월요일로 명시되는 휴일효과는 무시된다. 그래서 모형에 꼭 휴일효과의 반영이 필요하다면, 휴일효과를 해당 효과를 적용하길 원하는 날짜로 이동시켜야 한다. 

그리고, 월별 또는 주별 주기를 갖는 자료에서 사실 대부분의 휴일효과는 연별 계절성에 의해 잘 잡힌다. 다만, 시계열이 관측된 기간내에 다른 주에 발생하는 휴일효과들이 존재한다면, 해당 휴일에 대해서만 휴일 효과를 추가해줄 필요가 있다(e.g. 우리나라의 음력을 따르는 명절은 매해 다른 날짜에 발생).

### 2.8 Diagnostics
Prophet에는 rolling window 기법을 이용한 교차검증(cross-validation)으로 모형 진단을 수행하는 기능도 포함되어있다. Prophet의 일반화 성능을 키우기 위해서는 $\tau$의 튜닝은 꼭 필요로 될 것이다. 교차검증의 수행을 위해서는 먼저 과거값과 미래값을 나누는 cutoff 포인트를 정해야 한다. 해당 지점까지 자료로 모형을 적합하고, 이후 원하는만큼 예측을 수행하여 실제값과 비교해 예측 오차를 계산할 수 있다. 다음의 그림은 Peyton Manning 자료로 과거 5년자료로 1년을 예측했다는 것을 나타낸다:
```{r figure3, echo = FALSE, fig.cap = "출처: facebook.github.io", fig.align = "center", out.width = "60%"}
knitr::include_graphics("./fig/diagnostics_fig1.png")
```

교차검증 과정은 `cross_validation()`으로 정해진 cutoffs에 대해서 자동으로 수행된다. 우리는 훈련자료(training data) 이용할 크기, cutoffs 날짜 간 간격, 원하는 예측 길이(forecast horizon)을 `cross_validation()`의 인수 `initial`, `period`, `horizon` 각각에 명시해주면 된다. 그럼 cutoffs는 자동으로 결정이 된다. 기본 설정은 `horizon`을 명시해줄 경우, `initial`은 `horizon` 길이의 3배, `period`는 `horizon` 길이의 절반으로 설정된다.

`cross_validation()`의 결과는 실제값 `y`, out-of-sample의 예측값 `yhat`, 예측 날짜, cutoff 날짜에 관한 정보를 각 열로 갖는 데이터프레임으로 주어지며, 이 데이터프레임의 `yhat`과 `y`를 예측 오차의 계산에 사용한다.

다음의 예에서는 cutoffs 간격을 180일로 하고 약 2년을 훈련자료로 1년 예측을 수행해 교차검증을 한 것이다. Peyton Manning 자료에 대해 수행하였고, 해당 자료는 약 8년치 자료로 교차검증 수행결과 총 11개의 조각이 사용되었다.
```{r, message = FALSE, cache = TRUE}
mod <- prophet(wp_log_peyton)
cv <- cross_validation(mod, initial = 730, period = 180, horizon = 365, units = 'days')
head(cv)
```

원하는 cutoffs가 있다면 custom을 할 수도 있다. 다음은 cutoffs의 간격을 6개월로 설정한 것이다:
```{r, message = FALSE, cache = TRUE}
cutoffs <- seq(ymd("2013-02-15"), ymd("2014-02-15"), by = "6 months")
cv2 <- cross_validation(mod, cutoffs = cutoffs, horizon = 365, units = 'days')
```

예측성능 평가 측도의 계산은 `performance_metrics()`으로 수행할 수 있다. 실제값 `y`를 `yhat`, `yhat_lower`, `yhat_upper`로 비교하여 평가 측도뿐만이 아닌 범위(coverage)도 계산해준다. 기본적으로 mean squared error (MSE), root mean squared error (RMSE), mean absolute error (MAE), mean absolute percent error (MAPE), median absolute percent error (MDAPE)와 각각의 범위를 제공해준다. 그리고, 해당 측도들은 각 예측시점에서 계산된다. 예를 들어, 앞서 만든 객체 `cv`로 계산을 한다고 하면, 각 예측시점마다 11개의 예측값으로 측도를 계산한다는 말이다.
```{r, message = FALSE, cache = TRUE}
metrics <- performance_metrics(cv)
head(metrics)
```

결과가 37일 후부터 제공되는 이유는, `performance_metrics()`의 `rolling_window`인수가 default로 10%가 설정되어 있어, 365일 후까지의 예측값의 10%인 36일은 각 window에 포함시켜버리기 때문이다. 만약, 모든 예측시점에 대한 평가측도를 확인하고 싶다면, `rolling_window = 0`로 설정하면 된다.:
```{r, message = FALSE, cache = TRUE}
performance_metrics(cv, rolling_window = 0) %>% 
  head
```

앞서 예측값의 10%인 36일가량을 window에 포함시켜 37일 후 미래시점을 예측했던 것과 달리 어떤 예측값도 window에 포함시키지 않았으므로, 37일 후의 예측값에 대한 성능은 저하됐을 것이다. 
```{r, message = FALSE, cache = TRUE}
performance_metrics(cv, rolling_window = 0) %>%
  filter(horizon > 36) %>% 
  head
```

그리고, 원하는 평가측도로의 시각화 기능도 제공한다:
```{r, message = FALSE, fig.align = "center", out.width = "60%", cache = TRUE}
plot_cross_validation_metric(cv, metric = 'mape')
```

그림의 파란색 선은 MAPE를 나타내며, 그에 따라 각 점은 APE(absolute percent error)를 나타낸다. 미래 시점의 한달정도까지는 약 5%의 MAPE 오차를 보이나, 1년 후 시점에 가까워질수록 약 11%까지 값이 증가하고 있다. 아울러, 해당 그림은 default로 `rolling_window = 0.1`이 설정되어 계산된 평가측도로부터 그려진 것으로, `rolling_window`을 키울수록 더 많은 예측값은 window에 포함하게 되므로 파란색 선은 더 평활될(smoother) 것이다. 그리고, 이러한 교차검증에서 주의할 점은 모형이 시계열의 모든 요소를 잘 추정할 수 있도록(특히, 계절성과 회귀자) 훈련자료의 길이(`initial`)를 충분히 길게 설정해야 한다는 것이다. 예컨데, 연별 계절성의 추정에는 최소 1년의 길이가 필요하고, 주별 계절성의 파악에는 최소 한 주가 포함되어야 한다.

#### 2.8.1 Hyperparameter tuning
교차검증은 `changepoint.prior.scale`($\tau$)와 `seasonality.prior.scale`($\nu^2$)과 같은 Prophet 모형의 초모수(hyperparameters) 튜닝에도 사용된다. 다만, Python의 Prophet 모형 패키지에서는 병렬 처리를 통한 교차검증(parallelizing cross validataion)을 제공하여 초모수 튜닝을 쉽고 빠르게 수행할 수 있으나, 아쉽게도 R에서는 관련 기능을 제공하지 않고있다. 아울러, Prophet 모형에는 튜닝에 고려될 수 있는 많은 모수가 존재하기 때문에, 모형의 성능을 개선하기 위해서는 이러한 과정이 꼭 필요로 된다. 

그래서, R에서 Prophet 모형의 초모수들을 튜닝하고 최적의 모형을 선정하기 위해서는 병렬처리를 통한 교차검증을 수행할 수 있는 패키지의 도움을 받아야할 듯하다. 이 부분에 대해서는 관련 자료를 좀 더 찾아보고 정리하여 글을 적어야겠다는 생각이 든다.`r emo::ji("cry")` 조금만 기다려주시길 부탁드려본다.. `r emo::ji("sob")` 마지막으로 Prophet 모형의 초모수 튜닝의 좋은 시작점이 될 수 있는 몇 가지 일반적인 권고사항을 적고 이번 챕터를 마친다:

* 튜닝할 수 있는 모수
  + `changepoint.prior.scale`($\tau$): $\tau$는 아마 Prophet의 적합에 가장 큰 영향을 미치는 모수에 해당 할 것이다. 추세의 유연성을 결정하며, 특히 추세 변화점에서 추세가 얼마나 변화될지에 관여한다. 값이 너무 작을경우, 추세는 과소적합(underfit) 될 것이고, 추세 변화로 모델링했어야 하는 분산이 잡음(noise) 항으로 처리 될 것이다. 반대로 값이 너무 클경우, 추세는 과적합 될 것이며, 아주 극단적으로 과적합된 추세로 모델링된 경우엔 추세가 연도별 계절성까지 잡아내는 상황에 놓이게 될 것이다. 해당 모수의 기본 설정은 0.05로 대부분의 시계열에 잘 작동하나, [0.001, 0.5]의 범위에서 조정될 수 있다. 그리고, 해당 모수는 [2.2.1](#anchor)에서 언급했듯이 Lasso 회귀의 목적함수에 쓰이는 L1-regularization의 역할과 동일한데, 이러한 regularization penalty와 같은 모수의 튜닝에는 종종 로그 스케일이 쓰이곤 한다.
  + `seasonality.prior.scale`($\sigma^2$): $\sigma^2$는 계절성의 유연성을 조절한다. $\tau$와 비슷하게, 너무 큰 값은 계절성의 과적합, 너무 작은 값은 계절성의 과소적합을 야기할 것이다. $\sigma^2$의 기본값은 10으로, $\tau$와는 달리 큰 값으로 설정되어 있어 regularization은 기본적으로 적용되지 않는다. 그 이유는, 계절성의 경우 푸리에 차수 $N$을 고려함으로써 무한합이 아닌 절단된(truncated) 푸리에 급수로 모형화되기 때문이다. 그래서, 계절성의 과적합은 왠만해선 발생하지 않는다. $\sigma^2$의 합리적인 튜닝 범위는 [0.01, 10]으로, 만약 계절성의 크기는 매우 작게 추정하길 원한다면 0.01로 설정하면 될 것이다. 아울러, 해당 모수 또한 [2.3.6](#anchor)에서 언급했듯이 Ridge penalty L2-regularization과 동일하므로 튜닝에 종종 로그 스케일이 쓰이곤 한다.
  + `holidays.prior.sacle`($\nu^2$): $\nu^2$은 휴일효과의 유연성을 조절한다. `seasonality.prior.scale`($\sigma^2$)과 유사하게, 기본값이 10으로 설정되어 있어 regularization은 기본적으로 적용되지 않는다. 그 이유는 보통 각 휴일효과의 날짜에는 많은 관측치들이 속하기 때문에, 휴일효과의 추정은 대체로 꽤 잘 이루어지기 때문이다. 아울러, $\nu^2$의 합리적 튜닝 범위도 [0.01, 10]에 해당하며, 이하 내용은 `seasonality.prior.scale`에서 언급한 것과 같다.
  + `seasonality.mode`: 

## **3 Additional Topics**
***

### 3.1 Saving models
### 3.2 Flat trend and custom trends
### 3.3 Updating fitted models

## **4 Getting Help and Contributing**